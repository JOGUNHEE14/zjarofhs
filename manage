from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import mysql.connector
from mysql.connector import errorcode
from typing import Optional

app = FastAPI()

# CORS 미들웨어 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["POST"],
    allow_headers=["*"],
)

# 데이터베이스 연결 정보
db_config = {
    'user': 'root',
    'password': 'qwer',
    'host': 'localhost',
    'database': 'mysql',
    'raise_on_warnings': True
}

# 데이터베이스 연결 생성 함수
def get_db_connection():
    try:
        connection = mysql.connector.connect(**db_config)
        return connection
    except mysql.connector.Error as err:
        if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
            raise HTTPException(status_code=500, detail="Database access denied")
        elif err.errno == errorcode.ER_BAD_DB_ERROR:
            raise HTTPException(status_code=500, detail="Database does not exist")
        else:
            raise HTTPException(status_code=500, detail=f"Database connection error: {err}")

# 사용자 정보 모델
class Submission(BaseModel):
    username: str
    password: str
    code: str
    status: Optional[str] = "submitted"  # 기본값을 "submitted"로 설정

# 데이터베이스에 사용자 정보 저장 함수
def save_user_info(username: str, password: str, status: Optional[str]):
    connection = get_db_connection()
    cursor = connection.cursor()
    try:
        insert_user_query = ("INSERT INTO users "
                             "(username, password, status) "
                             "VALUES (%s, %s, %s)")
        user_data = (username, password, status)
        cursor.execute(insert_user_query, user_data)
        connection.commit()
        user_id = cursor.lastrowid
        return user_id
    except mysql.connector.Error as err:
        connection.rollback()
        raise HTTPException(status_code=500, detail=f"Error saving user info: {err}")
    finally:
        cursor.close()
        connection.close()

# 데이터베이스에 코드 정보 저장 함수
def save_code_info(user_id: int, code: str):
    connection = get_db_connection()
    cursor = connection.cursor()
    try:
        insert_code_query = ("INSERT INTO codes "
                             "(user_id, code) "
                             "VALUES (%s, %s)")
        code_data = (user_id, code)
        cursor.execute(insert_code_query, code_data)
        connection.commit()
    except mysql.connector.Error as err:
        connection.rollback()
        raise HTTPException(status_code=500, detail=f"Error saving code info: {err}")
    finally:
        cursor.close()
        connection.close()

# 예약번호 생성 및 반환 함수
def generate_reservation_number(user_id: int):
    return f"RES-{user_id}"

# POST 요청 핸들러
@app.post("/submit-post")
async def submit_post(submission: Submission, background_tasks: BackgroundTasks):
    try:
        user_id = save_user_info(submission.username, submission.password, submission.status)
        save_code_info(user_id, submission.code)
        reservation_number = generate_reservation_number(user_id)
        background_tasks.add_task(send_reservation_number, submission.username, reservation_number)
        return {"message": "Data received successfully", "reservation_number": reservation_number}
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

# 예약번호를 사용자에게 전달하는 함수
def send_reservation_number(username: str, reservation_number: str):
    print(f"Sending reservation number {reservation_number} to user {username}")
